#+TITLE: R Data Structures
#+AUTHOR: Matloff / Birkenkrahe
#+SUBTITLE: DSC 101
#+OPTIONS: toc:nil num:nil
#+startup: hideblocks
* What will you learn?

  * Preview of important data structures
  * Vectors and scalars
  * Character strings
  * Matrices
  * Lists
  * Data Frames
  * Classes
  * Extended example

* Overview

  #+attr_html: :width 600px
  [[./img/datastructures.png]]

* Vectors and scalars
** Vectors

   * Storage modes: check ~?mode~
   * Functions: ~mode~, ~storage.mode~, ~typeof~
   * E.g. ~numeric~ (~double~ or ~integer~)
   * Create a numeric vector of three elements!

   #+begin_src R :session :results output
     x <- c(1,2,3)  # integer
     y <- rnorm(3)  # double
     z <- 1:3       # integer

     ## print all three
     x; y; z

     ## check mode
     mode(x)
     storage.mode(x)
     typeof(x)

     ## check mode
     mode(y)
     storage.mode(y)
     typeof(y)

     ## check mode
     mode(z)
     storage.mode(z)
     typeof(z)

   #+end_src

   #+RESULTS:
   #+begin_example
   [1] 1 2 3
   [1] 0.04861205 0.46457487 2.03646610
   [1] 1 2 3
   [1] "numeric"
   [1] "double"
   [1] "double"
   [1] "numeric"
   [1] "double"
   [1] "double"
   [1] "numeric"
   [1] "integer"
   [1] "integer"
   #+end_example

** Scalars

   * There are no scalars (numbers)
   * Scalars are one-element vectors
   * How could you show that?

   #+begin_src R :session :results output
     s <- 1
     s # prints vector of length 1

     ## change rownumber display
     Nile[1:17]
     options(width=100)
     Nile[1:17]
   #+end_src

   #+RESULTS:
   : [1] 1
   :  [1] 1120 1160  963 1210 1160 1160  813 1230 1370 1140  995  935 1110  994 1020  960 1180
   :  [1] 1120 1160  963 1210 1160 1160  813 1230 1370 1140  995  935 1110  994 1020  960 1180

* Character strings

  * Single-element vectors of mode ~character~
  * Assign ~x <- letters[1:3]~ and print ~x~
  * Check the mode of ~x~

  #+begin_src R :session :results output
    x <- letters[1:3]
    x
    mode(x)
  #+end_src

  #+RESULTS:
  : [1] "a" "b" "c"
  : [1] "character"

** String manipulation

   * Create one numeric, two character vectors
   * Concatenate character vectors with ~paste~
   * Split character vector with ~strsplit~

   #+begin_src R :session :results output
     ## define vectors
     x <- c(5,12,13)  # create numeric vector
     x                # print x
     length(x)        # print length of x
     mode(x)          # print mode of x

     y <- "abc"       # create character string
     y
     length(y)
     mode(y)

     z <- c("abc", "29 88")
     z
     length(z)
     mode(z)

     ## concatenate character strings
     u <- paste("abc","de","f")
     u
     length(u)

     ## split string according to blanks
     v <- strsplit(u, " ")
     v   # notice that v is a list with one vector as element
     length(v)      # list length
     length(v[[1]]) # vector element length
   #+end_src

   #+RESULTS:
   #+begin_example
   [1]  5 12 13
   [1] 3
   [1] "numeric"
   [1] "abc"
   [1] 1
   [1] "character"
   [1] "abc"   "29 88"
   [1] 2
   [1] "character"
   [1] "abc de f"
   [1] 1
   [[1]]
   [1] "abc" "de"  "f"
   [1] 1
   [1] 3
   #+end_example

* Conversion vs. coercion

  * ~character~ conversion: ~as.character~
  * ~numeric~ conversion: ~as.numeric~
  * Change numeric vector to character
  * Change character vector to numeric

  #+begin_src R :session :results output
    y # three real numbers
    yc <- as.character(y)
    yc
    mode(yc)

    x # three letters
    xn <- as.numeric(x)
    xn
    mode(xn)
  #+end_src

  #+RESULTS:
  : [1] "abc"
  : [1] "abc"
  : [1] "character"
  : [1]  5 12 13
  : [1]  5 12 13
  : [1] "numeric"

* Matrices

  * A matrix is a rectangular array of numbers
  * Matrices are vectors with rows and column attributes

** Create matrices with ~matrix~

   * ~matrix~ creates a matrix from input values

   #+begin_src R :session :results output
     A <- matrix()  # an empty 1 x 1 matrix
     A
     dim(A) # rows x columns

     B <- matrix(NA) # an empty 1 x 1 matrix
     B

     C <- matrix(c(1,2)) # a 2 x 1 matrix
     C
     is.matrix(C)   # check if it's a matrix
   #+end_src

   #+RESULTS:
   :      [,1]
   : [1,]   NA
   : [1] 1 1
   :      [,1]
   : [1,]   NA
   :      [,1]
   : [1,]    1
   : [2,]    2
   : [1] TRUE

** Attaching rows and columns

   * ~rbind~ attaches rows
   * ~cbind~ attaches columns

     #+begin_src R :session :results output
       D <- rbind(c(1,4),c(2,2))
       D

       E <- cbind(c(1,4),c(2,2))
       E
     #+end_src

     #+RESULTS:
     :      [,1] [,2]
     : [1,]    1    4
     : [2,]    2    2
     :      [,1] [,2]
     : [1,]    1    2
     : [2,]    4    2

** Matrix algebra

   * Matrices are multiplied with ~%*%~

   #+begin_src R :session :results output
     D %*% c(1,1)
     E %*% c(1,1)
     D %*% E
   #+end_src

   #+RESULTS:
   :      [,1]
   : [1,]    5
   : [2,]    4
   :      [,1]
   : [1,]    3
   : [2,]    6
   :      [,1] [,2]
   : [1,]   17   10
   : [2,]   10    8

** Matrix indexing

   * Matrices are indexed with two subscripts

   #+begin_src R :session :results output
     D
     D[1,2]  # row 1, col 2
     D[,2]   # col 2
     D[2,2]  # row 2, col 2
     D[1,]   # row 1
   #+end_src

   #+RESULTS:
   :      [,1] [,2]
   : [1,]    1    4
   : [2,]    2    2
   : [1] 4
   : [1] 4 2
   : [1] 2
   : [1] 1 4

* Lists

  * Lists can contain different data types
  * This is like a ~struct~ in C/C++
  * Access elements with two-part names

  #+begin_src R :session :results output
    x <- list(u=2, v="abc") # number and string as list
    x
    mode(x)

    x$u # access list element u
    x$v # access list element v

    y <- paste(x$u,x$v)  # concatenation leads to coercion
    y
    mode(y)
    length(y)
  #+end_src

  #+RESULTS:
  #+begin_example
  $u
  [1] 2

  $v
  [1] "abc"
  [1] "list"
  [1] 2
  [1] "abc"
  [1] "2 abc"
  [1] "character"
  [1] 1
  #+end_example

** Use of lists

   * Combine multiple values
   * Return list by function

   #+begin_src R :session :results output
     hist(Nile)       # produces graph
     hn <- hist(Nile) # save histogram as list
     mode(hn)         # mode of hn
     print(hn)        # print hn (we can also just type hn
   #+end_src

   #+RESULTS:
   #+begin_example
   [1] "list"
   $breaks
    [1]  400  500  600  700  800  900 1000 1100 1200 1300 1400

   $counts
    [1]  1  0  5 20 25 19 12 11  6  1

   $density
    [1] 0.0001 0.0000 0.0005 0.0020 0.0025 0.0019 0.0012 0.0011 0.0006 0.0001

   $mids
    [1]  450  550  650  750  850  950 1050 1150 1250 1350

   $xname
   [1] "Nile"

   $equidist
   [1] TRUE

   attr(,"class")
   [1] "histogram"
   #+end_example

   * More common way to show structure with ~str~

     #+begin_src R :session :results output
       str(hn)
     #+end_src

     #+RESULTS:
     : List of 6
     :  $ breaks  : int [1:11] 400 500 600 700 800 900 1000 1100 1200 1300 ...
     :  $ counts  : int [1:10] 1 0 5 20 25 19 12 11 6 1
     :  $ density : num [1:10] 0.0001 0 0.0005 0.002 0.0025 0.0019 0.0012 0.0011 0.0006 0.0001
     :  $ mids    : num [1:10] 450 550 650 750 850 950 1050 1150 1250 1350
     :  $ xname   : chr "Nile"
     :  $ equidist: logi TRUE
     :  - attr(*, "class")= chr "histogram"

* Data frames

  * Data frames are lists made of vectors
  * Vectors can have different modes
  * Data frames are rectangular but not matrices

** Create data frame

   * Turn a list into a data frame using ~data.frame~

   #+begin_src R :session :results output

     fam <- list(kids=c("Jack","Jill"), ages=c(12,10))
     fam
     d <- data.frame(fam)
     d

   #+end_src

   #+RESULTS:
   : $kids
   : [1] "Jack" "Jill"
   :
   : $ages
   : [1] 12 10
   :   kids ages
   : 1 Jack   12
   : 2 Jill   10

   * Turn vectors directly into a data frame

     #+begin_src R :session :results output

       df <- data.frame(kids=c("Jack","Jill"),ages=c(12,10))
       df

     #+end_src

     #+RESULTS:
     :   kids ages
     : 1 Jack   12
     : 2 Jill   10

** Read data frame from file

   * Use ~read.table~ or ~read.csv~
   * You can read in straight from the web

   #+begin_src R :session :results output
     ## read csv without header information
     pima_raw <-
       read.csv(file=
                  "https://raw.githubusercontent.com/jbrownlee/Datasets/master/pima-indians-diabetes.data.csv",
                header=FALSE, sep=,)
     head(pima_raw)
   #+end_src

   #+RESULTS:
   :   V1  V2 V3 V4  V5   V6    V7 V8 V9
   : 1  6 148 72 35   0 33.6 0.627 50  1
   : 2  1  85 66 29   0 26.6 0.351 31  0
   : 3  8 183 64  0   0 23.3 0.672 32  1
   : 4  1  89 66 23  94 28.1 0.167 21  0
   : 5  0 137 40 35 168 43.1 2.288 33  1
   : 6  5 116 74  0   0 25.6 0.201 30  0

   * [[https://www.kaggle.com/uciml/pima-indians-diabetes-database/version/1][Download from Kaggle]] and read in from local machine

   #+begin_src R :session :results output
     ## read csv with header information
     pima <- read.csv(file="/home/marcus/GitHub/dsc101/5_datastructures/data/diabetes.csv",
                      header=TRUE,
                      sep=,)
     str(pima)
   #+end_src

   #+RESULTS:
   #+begin_example
   'data.frame':        768 obs. of  9 variables:
    $ Pregnancies             : int  6 1 8 1 0 5 3 10 2 8 ...
    $ Glucose                 : int  148 85 183 89 137 116 78 115 197 125 ...
    $ BloodPressure           : int  72 66 64 66 40 74 50 0 70 96 ...
    $ SkinThickness           : int  35 29 0 23 35 0 32 0 45 0 ...
    $ Insulin                 : int  0 0 0 94 168 0 88 0 543 0 ...
    $ BMI                     : num  33.6 26.6 23.3 28.1 43.1 25.6 31 35.3 30.5 0 ...
    $ DiabetesPedigreeFunction: num  0.627 0.351 0.672 0.167 2.288 ...
    $ Age                     : int  50 31 32 21 33 30 26 29 53 54 ...
    $ Outcome                 : int  1 0 1 0 1 0 1 0 1 1 ...
   #+end_example

* Classes

  * R objects[fn:2] are instances of /classes/
  * Classes are /abstract/ data types[fn:1]
  * Class instances are R lists with a class name

** Class example: time series

   * The class of ~Nile~ is time series or ~ts~

   #+begin_src R :session :results output
     str(Nile)
     class(Nile)
   #+end_src

   #+RESULTS:
   :  Time-Series [1:100] from 1871 to 1970: 1120 1160 963 1210 1160 1160 813 1230 1370 1140 ...
   : [1] "ts"

** Class example: histogram

   * Non-graphical output of ~hist()~ has a class
   * Compare also with ~print(hn)~

   #+begin_src R :session :results output
     hn <- hist(Nile)  # create a histogram object hn
     mode(hn)          # the object is of mode "list'
     class(hn)         # its object class is "histogram"
   #+end_src

   #+RESULTS:
   : [1] "list"
   : [1] "histogram"

** What are classes good for?

   * Classes are used by /generic/ functions ([[chambers][Chambers, 2002]])
   * Generic = defines family of similar functions
   * Each function fits a specific class
   * This relates to R's package extensibility

** Generic function example: ~summary()~

   * Invoking ~summary()~ searches according to class, e.g.
     - Calling ~summary()~ on the output of ~hist()~
     - Calling ~summary()~ on the output of ~lm()~ (regression)

   #+begin_src R :session :results output
     summary(hn) # summarize histogram of Nile data set
     summary(Nile) # summarize time series of Nile data set
     summary(lm(1:100~Nile)) # summarize linear fit of Nile data set
   #+end_src

   #+RESULTS:
   #+begin_example
	    Length Class  Mode     
   breaks   11     -none- numeric  
   counts   10     -none- numeric  
   density  10     -none- numeric  
   mids     10     -none- numeric  
   xname     1     -none- character
   equidist  1     -none- logical
      Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
     456.0   798.5   893.5   919.4  1032.5  1370.0

   Call:
   lm(formula = 1:100 ~ Nile)

   Residuals:
       Min      1Q  Median      3Q     Max 
   -51.984 -22.428  -2.128  18.508  63.495 

   Coefficients:
		Estimate Std. Error t value Pr(>|t|)    
   (Intercept) 123.83948   14.32659   8.644 1.05e-13 ***
   Nile         -0.07977    0.01533  -5.204 1.07e-06 ***
   ---
   Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1

   Residual standard error: 25.81 on 98 degrees of freedom
   Multiple R-squared:  0.2165,	Adjusted R-squared:  0.2085 
   F-statistic: 27.08 on 1 and 98 DF,  p-value: 1.072e-06
   #+end_example

   * You can call ~plot()~ on just about any R object, e.g.
     - Call ~plot()~ on a time series like ~Nile~
     - Call ~plot()~ on a data frame like ~mtcars~

   #+begin_src R :session :results output 
     plot(Nile) # plot of Nile time series data
   #+end_src

   #+RESULTS:

   #+begin_src R :session :results output 
     plot(hn)  # plot histogram
   #+end_src

   #+RESULTS:

   #+begin_src R :session :results output 
     plot(mtcars) # plot of all mtcars variables
   #+end_src

   #+RESULTS:

* Extended example: regression analysis

** Objective and data

   We walk through a brief statistical regression analysis - fitting a
   linear function to a small data set, showing different R objects
   along the way.

   The file ~Examsquiz.txt~ contains grades. The numbers correspond to
   letter grades on a 5-point scale common in Continental Europe:

   | LETTER | POINT |
   |--------+-------|
   | A+     |   0.7 |
   | A      |   1.0 |
   | A-     |   1.3 |
   |--------+-------|
   | B+     |   1.7 |
   | B      |   2.0 |
   | B-     |   2.3 |
   |--------+-------|
   | C+     |   2.7 |
   | C      |   3.0 |
   | C-     |   3.3 |
   |--------+-------|
   | D+     |   3.7 |
   | D      |   4.0 |
   | D-     |   4.3 |
   |--------+-------|
   | F      |   5.0 |
   |--------+-------|

   Each row contains the data for one student consisting of the midterm
   examination grade, the final examination grade, and the average quiz
   grade.

   We want to see how well the midterm and quiz grades predict the
   student's final exam grade.

** Read data into R

   * Make sure you are in the right folder
   * Read in data file using ~read.table()~
   * Don't read the first row as ~header~ (default)

   #+begin_src R :session :results output
     setwd("/home/marcus/GitHub/dsc101/5_datastructures")
     examsquiz <- read.table(file="./data/ExamsQuiz.txt", header=FALSE)
   #+end_src

   * Take a look at the data with ~head()~
   * R assigns default column vector names

   #+begin_src R :session :results output
     head(examsquiz)
   #+end_src

   #+RESULTS:
   :    V1  V2 V3
   : 1 3.0 1.0  1
   : 2 2.7 2.3  1
   : 3 3.7 1.7  1
   : 4 1.7 1.7  1
   : 5 5.0 1.7  1
   : 6 2.0 1.3  1

** Check R data

   * ~examsquiz~ is an R object of class ~data.frame~
   * ~str()~ also contains this information (and more)

   #+begin_src R :session :results output
     class(examsquiz)
     str(examsquiz)
   #+end_src

   #+RESULTS:
   : [1] "data.frame"
   : 'data.frame':      34 obs. of  3 variables:
   :  $ V1: num  3 2.7 3.7 1.7 5 2 3.7 4 1.7 5 ...
   :  $ V2: num  1 2.3 1.7 1.7 1.7 1.3 1.7 1.3 1.7 1.7 ...
   :  $ V3: num  1 1 1 1 1 1 1.3 1 1 1 ...

** Model data

   * Predict exam 2 score (~V2~) from exam 1 (~V1~)

     #+begin_src R :session :results output
       lma <- lm(examsquiz[,2] ~ examsquiz[,1]) # using indices
     #+end_src

   * The ~lm()~ function fits a linear prediction equation:

     predicted exam 2 = b_0 + b_1 * exam 1
   
   * Check out ~help(lm)~ and ~example(lm)~ for details

   How could we also have extracted the column vectors?

   #+begin_src R :session :results output
     lma <- lm(examsquiz$V2 ~ examsquiz$V1) # using accessor $
   #+end_src

   * 



* Concept summary


* Code summary

  | CODE | DESCRIPTION |
  |------+-------------|
  |      |             |

* References

  <<chambers>> Chambers J (2 Jan 2002). The Definition of Generic
  Functions and Methods [Website]. [[https://developer.r-project.org/methodDefinition.html][Online: r-project.org.]]

* Footnotes

[fn:2]Objects in R are "specialized data structures which can be
referred to through symbols or variables". These symbols are
themselves objects and accessible to programs.

[fn:1]These are S3 classes - the S stems from the predecessor to R,
the S language. S and R are object oriented languages - everything is
an object - but R objects are different from C++ or Java objects.
