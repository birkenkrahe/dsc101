#+TITLE: R Data Structures
#+AUTHOR: Matloff / Birkenkrahe
#+SUBTITLE: DSC 101
#+OPTIONS: toc:nil num:nil
#+startup: hideblocks
* What will you learn?

  * Preview of important data structures
  * Vectors and scalars
  * Character strings
  * Matrices
  * Lists
  * Data Frames
  * Classes
  * Extended example

* Overview

  #+attr_html: :width 600px
  [[./img/datastructures.png]]

* Vectors and scalars
** Vectors

   * Storage modes: check ~?mode~
   * Functions: ~mode~, ~storage.mode~, ~typeof~
   * E.g. ~numeric~ (~double~ or ~integer~)
   * Create a numeric vector of three elements!

   #+begin_src R :session :results output
     x <- c(1,2,3)  # integer
     y <- rnorm(3)  # double
     z <- 1:3       # integer

     ## print all three
     x; y; z

     ## check mode
     mode(x)
     storage.mode(x)
     typeof(x)

     ## check mode
     mode(y)
     storage.mode(y)
     typeof(y)

     ## check mode
     mode(z)
     storage.mode(z)
     typeof(z)

   #+end_src

   #+RESULTS:
   #+begin_example
   [1] 1 2 3
   [1] 0.04861205 0.46457487 2.03646610
   [1] 1 2 3
   [1] "numeric"
   [1] "double"
   [1] "double"
   [1] "numeric"
   [1] "double"
   [1] "double"
   [1] "numeric"
   [1] "integer"
   [1] "integer"
   #+end_example

** Scalars

   * There are no scalars (numbers)
   * Scalars are one-element vectors
   * How could you show that?

   #+begin_src R :session :results output
     s <- 1
     s # prints vector of length 1

     ## change rownumber display
     Nile[1:17]
     options(width=100)
     Nile[1:17]
   #+end_src

   #+RESULTS:
   : [1] 1
   :  [1] 1120 1160  963 1210 1160 1160  813 1230 1370 1140  995  935 1110  994 1020  960 1180
   :  [1] 1120 1160  963 1210 1160 1160  813 1230 1370 1140  995  935 1110  994 1020  960 1180

* Character strings

  * Single-element vectors of mode ~character~
  * Assign ~x <- letters[1:3]~ and print ~x~
  * Check the mode of ~x~

  #+begin_src R :session :results output
    x <- letters[1:3]
    x
    mode(x)
  #+end_src

  #+RESULTS:
  : [1] "a" "b" "c"
  : [1] "character"

** String manipulation

   * Create one numeric, two character vectors
   * Concatenate character vectors with ~paste~
   * Split character vector with ~strsplit~

   #+begin_src R :session :results output
     ## define vectors
     x <- c(5,12,13)  # create numeric vector
     x                # print x
     length(x)        # print length of x
     mode(x)          # print mode of x

     y <- "abc"       # create character string
     y
     length(y)
     mode(y)

     z <- c("abc", "29 88")
     z
     length(z)
     mode(z)

     ## concatenate character strings
     u <- paste("abc","de","f")
     u
     length(u)

     ## split string according to blanks
     v <- strsplit(u, " ")
     v   # notice that v is a list with one vector as element
     length(v)      # list length
     length(v[[1]]) # vector element length
   #+end_src

   #+RESULTS:
   #+begin_example
   [1]  5 12 13
   [1] 3
   [1] "numeric"
   [1] "abc"
   [1] 1
   [1] "character"
   [1] "abc"   "29 88"
   [1] 2
   [1] "character"
   [1] "abc de f"
   [1] 1
   [[1]]
   [1] "abc" "de"  "f"
   [1] 1
   [1] 3
   #+end_example

* Conversion vs. coercion

  * ~character~ conversion: ~as.character~
  * ~numeric~ conversion: ~as.numeric~
  * Change numeric vector to character
  * Change character vector to numeric

  #+begin_src R :session :results output
    y # three real numbers
    yc <- as.character(y)
    yc
    mode(yc)

    x # three letters
    xn <- as.numeric(x)
    xn
    mode(xn)
  #+end_src

  #+RESULTS:
  : [1] "abc"
  : [1] "abc"
  : [1] "character"
  : [1]  5 12 13
  : [1]  5 12 13
  : [1] "numeric"

* Matrices

  * A matrix is a rectangular array of numbers
  * Matrices are vectors with rows and column attributes

** Create matrices with ~matrix~

   * ~matrix~ creates a matrix from input values

   #+begin_src R :session :results output
     A <- matrix()  # an empty 1 x 1 matrix
     A
     dim(A) # rows x columns

     B <- matrix(NA) # an empty 1 x 1 matrix
     B

     C <- matrix(c(1,2)) # a 2 x 1 matrix
     C
     is.matrix(C)   # check if it's a matrix
   #+end_src

   #+RESULTS:
   :      [,1]
   : [1,]   NA
   : [1] 1 1
   :      [,1]
   : [1,]   NA
   :      [,1]
   : [1,]    1
   : [2,]    2
   : [1] TRUE

** Attaching rows and columns

   * ~rbind~ attaches rows
   * ~cbind~ attaches columns
     
     #+begin_src R :session :results output
       D <- rbind(c(1,4),c(2,2))
       D

       E <- cbind(c(1,4),c(2,2))
       E
     #+end_src

     #+RESULTS:
     :      [,1] [,2]
     : [1,]    1    4
     : [2,]    2    2
     :      [,1] [,2]
     : [1,]    1    2
     : [2,]    4    2

** Matrix algebra

   * Matrices are multiplied with ~%*%~

   #+begin_src R :session :results output
     D %*% c(1,1)
     E %*% c(1,1)
     D %*% E
   #+end_src

   #+RESULTS:
   :      [,1]
   : [1,]    5
   : [2,]    4
   :      [,1]
   : [1,]    3
   : [2,]    6
   :      [,1] [,2]
   : [1,]   17   10
   : [2,]   10    8

** Matrix indexing

   * Matrices are indexed with two subscripts

   #+begin_src R :session :results output
     D
     D[1,2]  # row 1, col 2
     D[,2]   # col 2
     D[2,2]  # row 2, col 2
     D[1,]   # row 1
   #+end_src

* Lists

  * Lists can contain different data types
  * This is like a ~struct~ in C/C++
  * Access elements with two-part names

  #+begin_src R :session :results output
    x <- list(u=2, v="abc") # number and string as list
    x
    mode(x)

    x$u # access list element u
    x$v # access list element v

    y <- paste(x$u,x$v)  # concatenation leads to coercion
    y
    mode(y)
    length(y)
  #+end_src

  #+RESULTS:
  #+begin_example
  $u
  [1] 2

  $v
  [1] "abc"
  [1] "list"
  [1] 2
  [1] "abc"
  [1] "2 abc"
  [1] "character"
  [1] 1
  #+end_example

** Use of lists

   * Combine multiple values
   * Return list by function

   #+begin_src R :session :results output
     hist(Nile)       # produces graph
     hn <- hist(Nile) # save histogram as list
     mode(hn)         # mode of hn
     print(hn)        # print hn (we can also just type hn
   #+end_src

   * More common way to show structure with ~str~

     #+begin_src R :session :results output
       str(hn)
     #+end_src

     #+RESULTS:
     : List of 6
     :  $ breaks  : int [1:11] 400 500 600 700 800 900 1000 1100 1200 1300 ...
     :  $ counts  : int [1:10] 1 0 5 20 25 19 12 11 6 1
     :  $ density : num [1:10] 0.0001 0 0.0005 0.002 0.0025 0.0019 0.0012 0.0011 0.0006 0.0001
     :  $ mids    : num [1:10] 450 550 650 750 850 950 1050 1150 1250 1350
     :  $ xname   : chr "Nile"
     :  $ equidist: logi TRUE
     :  - attr(*, "class")= chr "histogram"

* Data frames

  * Data frames are lists made of vectors
  * Vectors can have different modes
  * Data frames are rectangular but not matrices

** Create data frame

   * Turn a list into a data frame using ~data.frame~

   #+begin_src R :session :results output
     fam <- list(kids=c("Jack","Jill"), ages=c(12,10))
     fam
     d <- data.frame(fam)
     d
   #+end_src

   * Turn vectors directly into a data frame

     #+begin_src R :session :results output
       df <- data.frame(kids=c("Jack","Jill"),ages=c(12,10))
       df
     #+end_src

** Read data frame from file

   * Use ~read.table~ or ~read.csv~
   * You can read in straight from the web

   #+begin_src R :session :results output
     ## read csv without header information
     pima_raw <-
       read.csv(file=
                  "https://raw.githubusercontent.com/jbrownlee/Datasets/master/pima-indians-diabetes.data.csv",
                header=FALSE, sep=,)
     head(pima_raw)
     str(pima_raw)
   #+end_src

   * [[https://www.kaggle.com/uciml/pima-indians-diabetes-database/version/1][Download from Kaggle]] and read in from local machine

   #+begin_src R :session :results output
     ## read csv with header information
     pima <- read.csv(file="/home/marcus/GitHub/dsc101/5_datastructures/data/diabetes.csv",
                      header=TRUE,
                      sep=,)
     head(pima)
     str(pima)
   #+end_src

* Classes

  * R objects[fn:2] are instances of /classes/
  * Classes are /abstract/ data types[fn:1]
  * Class instances are R lists with a class name

** Class example: time series

   * The class of ~Nile~ is time series or ~ts~

   #+begin_src R :session :results output
     str(Nile)
     class(Nile)
   #+end_src

** Class example: histogram

   * Non-graphical output of ~hist()~ has a class
   * Compare also with ~print(hn)~

   #+begin_src R :session :results output
     hn <- hist(Nile)  # create a histogram object hn
     mode(hn)          # the object is of mode "list'
     class(hn)         # its object class is "histogram"
   #+end_src

** What are classes good for?

   * Classes are used by /generic/ functions ([[chambers][Chambers, 2002]])
   * Generic = defines family of similar functions
   * Each function fits a specific class
   * This relates to R's package extensibility

** Generic function example: ~summary()~

   * Invoking ~summary()~ searches according to class, e.g.
     - Calling ~summary()~ on the output of ~hist()~
     - Calling ~summary()~ on the output of ~lm()~ (regression)

   #+begin_src R :session :results output
     summary(hn)
     summary(lm(mtcars))
   #+end_src

   * You can call ~plot()~ on just about any R object, e.g.
     - Call ~plot()~ on a time series like ~Nile~
     - Call ~plot()~ on a data frame like ~mtcars~

   #+begin_src R :session :results output
     plot(Nile)
     plot(mtcars)
   #+end_src

* Extended example: regression analysis

* Concept summary


* Code summary

  | CODE | DESCRIPTION |
  |------+-------------|
  |      |             |

* References

  <<chambers>> Chambers J (2 Jan 2002). The Definition of Generic
  Functions and Methods [Website]. [[https://developer.r-project.org/methodDefinition.html][Online: r-project.org.]]

* Footnotes

[fn:2]Objects in R are "specialized data structures which can be
referred to through symbols or variables". These symbols are
themselves objects and accessible to programs.

[fn:1]These are S3 classes - the S stems from the predecessor to R,
the S language. S and R are object oriented languages - everything is
an object - but R objects are different from C++ or Java objects.
